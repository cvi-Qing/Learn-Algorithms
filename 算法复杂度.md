# 算法复杂度

目标：算法的效率评估

**时间复杂度:运行时间的长短**

**空间复杂度:占用内存的大小**

实际情况

类似A算法B算法都能解决问题，就需要考虑时间跟空间复杂度

# 迭代与递归

**迭代**：重复执行某个任务的控制结构，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足(就是循环)

### 1、for 循环

```python
def number(a):
    sum = 0
    i = 1
    while i <= a:
        sum += i
        i += 1
    return sum
```

### 2、 while 循环

````python
def while_loop(n: int) -> int:
    """while 循环"""
    res = 0
    i = 1  # 初始化条件变量
    # 循环求和 1, 2, ..., n-1, n
    while i <= n:
        res += i
        i += 1  # 更新条件变量
    return res
````



### 3、  嵌套循环

![image-20250809145248735](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20250809145248735.png)



### 4、迭代与递归

递归（recursion）是一种算法策略，通过函数调用自身来解决问题，认为就是函数调用

```` python
def recur(n: int) -> int:
    """递归"""
    # 终止条件
    if n == 1:
        return 1
    # 递：递归调用
    res = recur(n - 1)
    # 归：返回结果
    return n + res
````

![求和函数的递归过程](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum.png)



#### 调用栈

递归函数每次调用自身时，系统都会为新开启的函数分配内存，**因此递归通常比循环的时间效率更低**

#### 尾递归

**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当，普通递归和尾递归，两者的求和操作的执行点是不同的

- **普通递归**：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。
- **尾递归**：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。

类似 1+2+3+...+n

````python
def tail_recur(n, res):
    """尾递归"""
    # 终止条件
    if n == 0:
        return res
    # 尾递归调用
    return tail_recur(n - 1, res + n)
````

![尾递归过程](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/tail_recursion_sum.png)

#### 递归树

类似“斐波那契数列”，给定一个斐波那契数列 ，求该数列的第 个数字。

数列核心算法

````python
f(1)=1
f(2)=2
f(n)=f(n-1)+f(n-2) #第n个数的值为前两个数相加

def fib(n):
    if n == 1 or n ==2:
        return n-1
    res = fib(n-1) + fib(n-2)
    return res
````

![斐波那契数列的递归树](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png)

# 时间复杂度

反映算法的效率

1. **确定运行平台**，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。
2. **评估各种计算操作所需的运行时间**，例如加法操作 `+` 需要 1 ns ，乘法操作 `*` 需要 10 ns ，打印操作 `print()` 需要 5 ns 等。
3. **统计代码中所有的计算操作**，并将所有操作的执行时间求和，从而得到运行时间

````python
# 在某运行平台下
def algorithm(n: int):
    a = 2      # 1 ns
    a = a + 1  # 1 ns
    a = a * 2  # 10 ns
    # 循环 n 次
    for _ in range(n):  # 1 ns
        print(0)        # 5 ns
````

这个程序的时间复杂度应该为 6n+12,

但是个人认为统计复杂度不现实，时间和运行平台绑定，不同的设备运行不同的程序很难保证时间一致

# 空间复杂度

- **暂存空间**：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
- **输出空间**：用于存储算法的输出数据

空间复杂度的统计范围是“暂存空间”加上“输出空间”

常见的类型

![image-20250809200541499](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20250809200541499.png)

### 常数阶 

常数阶常见于数量与输入数据大小 无关的常量、变量、对象

````python
def function() -> int:
    """函数"""
    # 执行某些操作
    return 0

def constant(n: int):
    """常数阶"""
    # 常量、变量、对象占用 O(1) 空间
    a = 0
    nums = [0] * 10000
    node = ListNode(0)
    # 循环中的变量占用 O(1) 空间
    for _ in range(n):
        c = 0
    # 循环中的函数占用 O(1) 空间
    for _ in range(n):
        function()
````

### 线性阶 

线性阶常见于元素数量与 成正比的数组、链表、栈、队列等

````python
def linear(n: int):
    """线性阶"""
    # 长度为 n 的列表占用 O(n) 空间
    nums = [0] * n
    # 长度为 n 的哈希表占用 O(n) 空间
    hmap = dict[int, str]()
    for i in range(n):
        hmap[i] = str(i)
````

### 平方阶 

平方阶常见于矩阵和图，元素数量与 成平方关系

````python
def quadratic(n: int):
    """平方阶"""
    # 二维列表占用 O(n^2) 空间
    num_matrix = [[0] * n for _ in range(n)]
````

### 指数阶 

指数阶常见于二叉树

````python
def build_tree(n: int) -> TreeNode | None:
    """指数阶（建立满二叉树）"""
    if n == 0:
        return None
    root = TreeNode(0)
    root.left = build_tree(n - 1)
    root.right = build_tree(n - 1)
    return root
````

![满二叉树产生的指数阶空间复杂度](https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png)

### 对数阶 

对数阶常见于分治算法。例如归并排序，输入长度为 的数组，每轮递归将数组从中点处划分为两半，形成高度为 的递归树，使用 栈帧空间

## 程序练习

### 冒泡排序

````python
#冒泡pao 排序 第一步 两个数的交换
#索引下标0开始
nums = [5, 4, 3, 2, 1]
def bubble(nums: list[int]):
    for i in range(len(nums)-1):  # 控制比较的轮数
        for j in range(0, len(nums)-1-i):  # 左边闭合右边开放
            if nums[j] > nums[j+1]:  # 如果当前数比下一个数大
                # 交换两个数的位置
                nums[j], nums[j+1] = nums[j+1], nums[j]
        print(nums)
bubble(nums)

--------------------------->
[4, 3, 2, 1, 5]
[3, 2, 1, 4, 5]
[2, 1, 3, 4, 5]
[1, 2, 3, 4, 5]
````

斐波那契数列